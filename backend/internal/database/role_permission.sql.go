// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: role_permission.sql

package database

import (
	"context"

	"github.com/lib/pq"
)

const getResourcePermissionByRole = `-- name: GetResourcePermissionByRole :one
SELECT role, permissions->> $1::VARCHAR as permissions FROM role_permission 
WHERE role = $2::role_enum
`

type GetResourcePermissionByRoleParams struct {
	Resource string
	Role     RoleEnum
}

type GetResourcePermissionByRoleRow struct {
	Role        RoleEnum
	Permissions interface{}
}

func (q *Queries) GetResourcePermissionByRole(ctx context.Context, arg GetResourcePermissionByRoleParams) (GetResourcePermissionByRoleRow, error) {
	row := q.db.QueryRowContext(ctx, getResourcePermissionByRole, arg.Resource, arg.Role)
	var i GetResourcePermissionByRoleRow
	err := row.Scan(&i.Role, &i.Permissions)
	return i, err
}

const getResourcePermissionByRoles = `-- name: GetResourcePermissionByRoles :many
SELECT role, permissions->> $1::VARCHAR as permissions FROM role_permission 
WHERE role = ANY($2::role_enum[])
`

type GetResourcePermissionByRolesParams struct {
	Resource string
	Roles    []RoleEnum
}

type GetResourcePermissionByRolesRow struct {
	Role        RoleEnum
	Permissions interface{}
}

func (q *Queries) GetResourcePermissionByRoles(ctx context.Context, arg GetResourcePermissionByRolesParams) ([]GetResourcePermissionByRolesRow, error) {
	rows, err := q.db.QueryContext(ctx, getResourcePermissionByRoles, arg.Resource, pq.Array(arg.Roles))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourcePermissionByRolesRow
	for rows.Next() {
		var i GetResourcePermissionByRolesRow
		if err := rows.Scan(&i.Role, &i.Permissions); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
